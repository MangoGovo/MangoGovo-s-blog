<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/10/18/%E6%B5%81%E9%87%8F%E5%88%87%E6%8D%A2%E4%BB%A5%E5%8F%8A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%96%B9%E6%A1%88/"/>
    <url>/2024/10/18/%E6%B5%81%E9%87%8F%E5%88%87%E6%8D%A2%E4%BB%A5%E5%8F%8A%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="流量切换以及负载均衡方案-初稿"><a href="#流量切换以及负载均衡方案-初稿" class="headerlink" title="流量切换以及负载均衡方案(初稿)"></a>流量切换以及负载均衡方案(初稿)</h1><h2 id="当前的问题"><a href="#当前的问题" class="headerlink" title="当前的问题"></a><strong>当前的问题</strong></h2><p>目前有四条api可以从zf获取数据</p><ul><li>外网统一</li><li>内网统一</li><li>外网正方</li><li>内网正方</li></ul><p>四条api都存在着不稳定的特点，响应时间也较长。同时内网会在晚上自动屏蔽，这也给负载带来了挑战</p><p>对于响应时间较长的问题，可以使用负载均衡在最大限度上提供保障。</p><p>但是由于api不稳定的特性，就有必要检测api的健康状态，需要在一条api出现问题的时候自动将api从负载均衡的列表中移除，并在恢复健康后重新添加到列表中。</p><h2 id="目前的方案"><a href="#目前的方案" class="headerlink" title="目前的方案"></a><strong>目前的方案</strong></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>根据gin反馈的接口反馈(请求耗时, 状态码), 记录请求的<strong>失败率</strong>以及请求的<strong>耗时</strong>等,结合多个参数对四条线路评估, 用于评估该条线路的质量. 便于进行分流.</p><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a><strong>工作队列</strong></h3><p>使用一个<strong>优先队列</strong>用于维护所有<strong>参与请求处理</strong>的线路, 根据线路的质量来评判<strong>优先级</strong>, 优先级高的优先参与请求的处理, 当一个线路挂了, 就将其加入<strong>死亡队列</strong>进行<strong>唤醒</strong>.</p><h3 id="死亡队列"><a href="#死亡队列" class="headerlink" title="死亡队列"></a><strong>死亡队列</strong></h3><p>死亡队列用于存放在工作队列中挂掉的线路, 单独起一个goroutine来定时发送请求来<strong>唤醒</strong>, 直到可以<strong>成功请求</strong>并<strong>延时优秀</strong>再将其重新添加回工作队列, 并赋予<strong>低优先级(避免抖动,<strong>让其重新参与底层工作,通过工作队列的竞争机制来获得高优先级</strong>)</strong></p><h3 id="如何去维护工作队列"><a href="#如何去维护工作队列" class="headerlink" title="如何去维护工作队列"></a><strong>如何去维护工作队列</strong></h3><p>使用<strong>redis</strong>记录最近<strong>十分钟</strong>的所有请求, 每隔一定时间起一个goroutine进行一次<strong>统计</strong>以及<strong>排序</strong>并<strong>更新工作队列</strong></p><h3 id="更新工作队列"><a href="#更新工作队列" class="headerlink" title="更新工作队列"></a><strong>更新工作队列</strong></h3><p>更新工作队列时为了保证请求的稳定性, 不能修改原工作队列, 而是新开一个工作队列, 并在完成统计工作后将请求指向新的工作队列. <strong>重定向的过程得加锁, 应该是并发造成的数据不一致问题</strong></p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a><strong>负载均衡策略</strong></h3><p>根据工作队列, 分配任务量给各个线路,<br>$$<br>流量分配比例:T_i&#x3D;\left(\frac{\frac{1}{x_i}}{\sum \frac{1}{x_i}}\right) \times 100%   (其中x_i表示线路i的延时)<br>$$</p><p>采用加权<a href="https://www.pdai.tech/md/algorithm/alg-domain-load-balance.html#%E9%9A%8F%E6%9C%BA%E6%B3%95-random">随机法</a>生成一个0-1的随机浮点数来决定采用哪个线路.</p><h3 id="告警"><a href="#告警" class="headerlink" title="告警"></a><strong>告警</strong></h3><p>当有线路长时间在死亡队列中(2h?), 无法唤醒, 发邮件告警.</p><h3 id="针对内网的处理"><a href="#针对内网的处理" class="headerlink" title="针对内网的处理"></a><strong>针对内网的处理</strong></h3><ol><li><p>每天24点后自动把内网的接口踢出<strong>工作队列</strong>.</p></li><li><p>每天6点把内网接口加入<strong>死亡队列</strong>进行<strong>唤醒</strong>.</p><p><img src="/./img/overviewOfPayloadBalance.png" alt="OverView"></p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>这是我第一篇博客</title>
    <link href="/2024/10/08/%E8%BF%99%E6%98%AF%E6%88%91%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/10/08/%E8%BF%99%E6%98%AF%E6%88%91%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="终于部署好了"><a href="#终于部署好了" class="headerlink" title="终于部署好了"></a>终于部署好了</h1><p>这是我的第一篇博客</p>]]></content>
    
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
